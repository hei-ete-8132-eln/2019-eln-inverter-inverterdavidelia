-- VHDL Entity Board.FPGA_inverterControl.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:22:59 10/23/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FPGA_inverterControl IS
    GENERIC( 
        buttonNb : positive := 4;
        ledNb    : positive := 8
    );
    PORT( 
        buttons_n  : IN     std_uLogic_vector (1 TO buttonNb);
        clock      : IN     std_ulogic;
        reset_n    : IN     std_ulogic;
        LED1       : OUT    std_uLogic;
        LED2       : OUT    std_ulogic;
        LEDs_n     : OUT    std_ulogic_vector (1 TO ledNb);
        lp_PWM1    : OUT    std_uLogic;
        lp_PWM2    : OUT    std_ulogic;
        lp_trigger : OUT    std_uLogic;
        pwm1High   : OUT    std_uLogic;
        pwm1Low_n  : OUT    std_uLogic;
        pwm2High   : OUT    std_uLogic;
        pwm2Low_n  : OUT    std_uLogic;
        trigger    : OUT    std_uLogic
    );

-- Declarations

END FPGA_inverterControl ;





-- VHDL Entity Inverter.inverterControl.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:40:46 10/23/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY inverterControl IS
    GENERIC( 
        clockFrequency   : real     := 66.0E6;
        mainsFrequency   : real     := 50.0;
        pwmFrequency     : real     := 100.0E3;
        nonOverlapPeriod : real     := 1.0E-6;
        phaseBitNb       : positive := 32;
        sineAmplitude    : real     := 1.0;
        pwmBitNb         : positive := 10;
        testLineNb       : positive := 8
    );
    PORT( 
        clock           : IN     std_ulogic;
        doubleFrequency : IN     std_uLogic;
        pwmCountEn      : IN     std_uLogic;
        reset           : IN     std_ulogic;
        sampleEn        : IN     std_uLogic;
        switchEvenOdd   : IN     std_uLogic;
        threeLevel      : IN     std_uLogic;
        pwm1High        : OUT    std_uLogic;
        pwm1Low_n       : OUT    std_uLogic;
        pwm2High        : OUT    std_uLogic;
        pwm2Low_n       : OUT    std_uLogic;
        testOut         : OUT    std_uLogic_vector (1 TO testLineNb);
        trigger         : OUT    std_uLogic
    );

-- Declarations

END inverterControl ;





LIBRARY ieee;
USE ieee.std_logic_1164.all;

PACKAGE gates IS

--  constant gateDelay: time := 1 ns;
  constant gateDelay: time := 0.1 ns;

END gates;




-- VHDL Entity gates.inverter.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:14 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY inverter IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END inverter ;





ARCHITECTURE sim OF inverter IS
BEGIN
  out1 <= NOT in1 after delay;
END sim;




-- VHDL Entity gates.bufferUlogic.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:34:48 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY bufferUlogic IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END bufferUlogic ;





ARCHITECTURE sim OF bufferUlogic IS
BEGIN
  out1 <= in1 after delay;
END ARCHITECTURE sim;




-- VHDL Entity Inverter.nonOverlap.symbol
--
-- Created:
--          by - elia.scapini.UNKNOWN (WEA20305)
--          at - 15:38:22 05.12.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY nonOverlap IS
    GENERIC( 
        counterBitNb : positive := 8
    );
    PORT( 
        clock    : IN     std_ulogic;
        driveEn  : IN     std_ulogic;
        pwmIn    : IN     std_ulogic;
        reset    : IN     std_ulogic;
        pwmOut   : OUT    std_ulogic;
        pwmOut_n : OUT    std_ulogic
    );

-- Declarations

END nonOverlap ;





-- VHDL Entity Inverter.Machineetat.interface
--
-- Created:
--          by - elia.scapini.UNKNOWN (WEA20305)
--          at - 14:22:22 09.12.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

ENTITY Machineetat IS
    GENERIC( 
        counterBitNb : positive
    );
    PORT( 
        clock    : IN     std_ulogic;
        countOut : IN     unsigned (counterBitNb-1 DOWNTO 0);
        driveEn  : IN     std_ulogic;
        pwmIn    : IN     std_ulogic;
        reset    : IN     std_ulogic;
        enable   : OUT    std_ulogic;
        pwmOut   : OUT    std_ulogic;
        pwmOut_n : OUT    std_ulogic
    );

-- Declarations

END Machineetat ;





--
-- VHDL Architecture Inverter.Machineetat.fsm
--
-- Created:
--          by - elia.scapini.UNKNOWN (WEA20305)
--          at - 16:16:19 09.12.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
 
ARCHITECTURE fsm OF Machineetat IS

    TYPE STATE_TYPE IS (
        pwm0,
        countPwm,
        pH,
        PWMDown,
        Pdown
    );
 
    -- Declare current and next state signals
    SIGNAL current_state : STATE_TYPE;
    SIGNAL next_state : STATE_TYPE;

BEGIN

    -----------------------------------------------------------------
    clocked_proc : PROCESS ( 
        clock,
        reset
    )
    -----------------------------------------------------------------
    BEGIN
        IF (reset = '1') THEN
            current_state <= pwm0;
        ELSIF (clock'EVENT AND clock = '1') THEN
            current_state <= next_state;
        END IF;
    END PROCESS clocked_proc;
 
    -----------------------------------------------------------------
    nextstate_proc : PROCESS ( 
        countOut,
        current_state,
        pwmIn
    )
    -----------------------------------------------------------------
    BEGIN
        CASE current_state IS
            WHEN pwm0 => 
                IF (pwmIn = '1') THEN 
                    next_state <= countPwm;
                ELSE
                    next_state <= pwm0;
                END IF;
            WHEN countPwm => 
                IF (countOut+1=0) THEN 
                    next_state <= pH;
                ELSE
                    next_state <= countPwm;
                END IF;
            WHEN pH => 
                IF (pwmIn = '0') THEN 
                    next_state <= PWMDown;
                ELSE
                    next_state <= pH;
                END IF;
            WHEN PWMDown => 
                IF (countOut+1=0) THEN 
                    next_state <= Pdown;
                ELSE
                    next_state <= PWMDown;
                END IF;
            WHEN Pdown => 
                IF (pwmIn = '1') THEN 
                    next_state <= countPwm;
                ELSE
                    next_state <= Pdown;
                END IF;
            WHEN OTHERS =>
                next_state <= pwm0;
        END CASE;
    END PROCESS nextstate_proc;
 
    -----------------------------------------------------------------
    output_proc : PROCESS ( 
        current_state
    )
    -----------------------------------------------------------------
    BEGIN
        -- Default Assignment
        enable <= '0';
        pwmOut <= '0';
        pwmOut_n <= '0';

        -- Combined Actions
        CASE current_state IS
            WHEN pwm0 => 
                enable <= '0' ;
            WHEN countPwm => 
                enable <= '1' ;
            WHEN pH => 
                enable <= '0';
                pwmOut  <= '1';
            WHEN PWMDown => 
                enable <= '1' ;
            WHEN Pdown => 
                enable <= '0' ;
                pwmOut_n  <= '1';
            WHEN OTHERS =>
                NULL;
        END CASE;
    END PROCESS output_proc;
 
END fsm;




-- VHDL Entity sequential.counterEnable.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:46:19 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY counterEnable IS
    GENERIC( 
        bitNb : positive := 8;
        delay : time     := gateDelay
    );
    PORT( 
        clock    : IN     std_ulogic;
        enable   : IN     std_ulogic;
        reset    : IN     std_ulogic;
        countOut : OUT    unsigned (bitNb-1 DOWNTO 0)
    );

-- Declarations

END counterEnable ;





--------------------------------------------------------------------------------
-- Copyright 2013 HES-SO Valais Wallis (www.hevs.ch)
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
--------------------------------------------------------------------------------
-- Counter
--   Simple counter with a generic width of nbBits.
--
--   Created on 2013-08-10
--
--   Version: 1.0
--   Author: Oliver A. Gubler (oliver.gubler@hevs.ch)
--------------------------------------------------------------------------------
--
ARCHITECTURE rtl OF counterEnable IS
  
  signal sCountOut: unsigned(countOut'range);

BEGIN

  countEndlessly: process(reset, clock)
  begin
    if reset = '1' then
      sCountOut <= (others => '0');
    elsif rising_edge(clock) then
      if enable = '1' then
        sCountOut <= sCountOut + 1;
      end if;
    end if;
  end process countEndlessly;
  
  countOut <= sCountOut after delay;

END ARCHITECTURE RTL;




--
-- VHDL Architecture Inverter.nonOverlap.studentVersion
--
-- Created:
--          by - elia.scapini.UNKNOWN (WEA20305)
--          at - 15:07:42 09.12.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

-- LIBRARY Inverter;
-- LIBRARY sequential;

ARCHITECTURE studentVersion OF nonOverlap IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL countOut : unsigned(counterBitNb-1 DOWNTO 0);
    SIGNAL enable   : std_ulogic;


    -- Component Declarations
    COMPONENT Machineetat
    GENERIC (
        counterBitNb : positive
    );
    PORT (
        clock    : IN     std_ulogic ;
        countOut : IN     unsigned (counterBitNb-1 DOWNTO 0);
        driveEn  : IN     std_ulogic ;
        pwmIn    : IN     std_ulogic ;
        reset    : IN     std_ulogic ;
        enable   : OUT    std_ulogic ;
        pwmOut   : OUT    std_ulogic ;
        pwmOut_n : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT counterEnable
    GENERIC (
        bitNb : positive := 8;
        delay : time     := gateDelay
    );
    PORT (
        clock    : IN     std_ulogic ;
        enable   : IN     std_ulogic ;
        reset    : IN     std_ulogic ;
        countOut : OUT    unsigned (bitNb-1 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : Machineetat USE ENTITY Inverter.Machineetat;
--     FOR ALL : counterEnable USE ENTITY sequential.counterEnable;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    I0 : Machineetat
        GENERIC MAP (
            counterBitNb => counterBitNb
        )
        PORT MAP (
            clock    => clock,
            countOut => countOut,
            driveEn  => driveEn,
            pwmIn    => pwmIn,
            reset    => reset,
            enable   => enable,
            pwmOut   => pwmOut,
            pwmOut_n => pwmOut_n
        );
    I2 : counterEnable
        GENERIC MAP (
            bitNb => counterBitNb,
            delay => gateDelay
        )
        PORT MAP (
            clock    => clock,
            enable   => enable,
            reset    => reset,
            countOut => countOut
        );

END studentVersion;




-- VHDL Entity Inverter.phaseCounter.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:23:19 10/23/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY phaseCounter IS
    GENERIC( 
        phaseBitNb : positive := 16
    );
    PORT( 
        clock : IN     std_ulogic;
        en    : IN     std_uLogic;
        reset : IN     std_ulogic;
        step  : IN     unsigned (phaseBitNb-1 DOWNTO 0);
        phase : OUT    unsigned (phaseBitNb-1 DOWNTO 0)
    );

-- Declarations

END phaseCounter ;





-- VHDL Entity sequential.registerUnsigned.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:46:18 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY registerUnsigned IS
    GENERIC( 
        delay         : time     := gateDelay;
        registerBitNb : positive := 8
    );
    PORT( 
        clock   : IN     std_ulogic;
        dataIn  : IN     unsigned (registerBitNb-1 DOWNTO 0);
        enable  : IN     std_ulogic;
        reset   : IN     std_ulogic;
        dataOut : OUT    unsigned (registerBitNb-1 DOWNTO 0)
    );

-- Declarations

END registerUnsigned ;





ARCHITECTURE sim OF registerUnsigned IS
BEGIN

  registerData: process(reset, clock)
  begin
    if reset = '1' then
      dataOut <= (others => '0') after delay;
    elsif rising_edge(clock) then
      if enable = '1' then
        dataOut <= dataIn after delay;
      end if;
    end if;
  end process registerData;

END ARCHITECTURE sim;





-- VHDL Entity operators.addUnsigned.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:37:25 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY addUnsigned IS
    GENERIC( 
        dataBitNb : positive := 8;
        delay     : time     := gateDelay
    );
    PORT( 
        in1  : IN     unsigned (dataBitNb-1 DOWNTO 0);
        in2  : IN     unsigned (dataBitNb-1 DOWNTO 0);
        out1 : OUT    unsigned (dataBitNb-1 DOWNTO 0)
    );

-- Declarations

END addUnsigned ;





ARCHITECTURE sim OF addUnsigned IS
BEGIN
  out1 <= in1 + in2 after delay;
END ARCHITECTURE sim;




--
-- VHDL Architecture Inverter.phaseCounter.studentVersion
--
-- Created:
--          by - elia.scapini.UNKNOWN (WEA20305)
--          at - 14:48:04 09.12.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

-- LIBRARY operators;
-- LIBRARY sequential;

ARCHITECTURE studentVersion OF phaseCounter IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL out1 : unsigned(phaseBitNb-1 DOWNTO 0);

    -- Implicit buffer signal declarations
    SIGNAL phase_internal : unsigned (phaseBitNb-1 DOWNTO 0);


    -- Component Declarations
    COMPONENT addUnsigned
    GENERIC (
        dataBitNb : positive := 8;
        delay     : time     := gateDelay
    );
    PORT (
        in1  : IN     unsigned (dataBitNb-1 DOWNTO 0);
        in2  : IN     unsigned (dataBitNb-1 DOWNTO 0);
        out1 : OUT    unsigned (dataBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT registerUnsigned
    GENERIC (
        delay         : time     := gateDelay;
        registerBitNb : positive := 8
    );
    PORT (
        clock   : IN     std_ulogic ;
        dataIn  : IN     unsigned (registerBitNb-1 DOWNTO 0);
        enable  : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    unsigned (registerBitNb-1 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : addUnsigned USE ENTITY operators.addUnsigned;
--     FOR ALL : registerUnsigned USE ENTITY sequential.registerUnsigned;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    I1 : addUnsigned
        GENERIC MAP (
            dataBitNb => phaseBitNb,
            delay     => gateDelay
        )
        PORT MAP (
            in1  => phase_internal,
            in2  => step,
            out1 => out1
        );
    I0 : registerUnsigned
        GENERIC MAP (
            delay         => gateDelay,
            registerBitNb => phaseBitNb
        )
        PORT MAP (
            clock   => clock,
            dataIn  => out1,
            enable  => en,
            reset   => reset,
            dataOut => phase_internal
        );

    -- Implicit buffered output assignments
    phase <= phase_internal;

END studentVersion;




-- VHDL Entity Inverter.pwmModulator.symbol
--
-- Created:
--          by - elia.scapini.UNKNOWN (WEA20305)
--          at - 13:57:50 16.12.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY pwmModulator IS
    GENERIC( 
        pwmBitNb : positive := 10
    );
    PORT( 
        amplitude       : IN     signed (pwmBitNb-1 DOWNTO 0);
        clock           : IN     std_ulogic;
        doubleFrequency : IN     std_ulogic;
        en              : IN     std_ulogic;
        reset           : IN     std_ulogic;
        switchEvenOdd   : IN     std_ulogic;
        threeLevel      : IN     std_ulogic;
        pwm1            : OUT    std_ulogic;
        pwm2            : OUT    std_ulogic
    );

-- Declarations

END pwmModulator ;





-- VHDL Entity operators.compareSigned.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:37:24 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY compareSigned IS
    GENERIC( 
        dataBitNb : positive := 8;
        delay     : time     := gateDelay
    );
    PORT( 
        a  : IN     signed (dataBitNb-1 DOWNTO 0);
        b  : IN     signed (dataBitNb-1 DOWNTO 0);
        eq : OUT    std_ulogic;
        ge : OUT    std_ulogic;
        gt : OUT    std_ulogic;
        le : OUT    std_ulogic;
        lt : OUT    std_ulogic
    );

-- Declarations

END compareSigned ;





ARCHITECTURE sim OF compareSigned IS
BEGIN

  gt <= '1' after delay when a > b
    else '0' after delay;

  ge <= '1' after delay when a >= b
    else '0' after delay;

  eq <= '1' after delay when a = b
    else '0' after delay;

  le <= '1' after delay when a <= b
    else '0' after delay;

  lt <= '1' after delay when a < b
    else '0' after delay;

END ARCHITECTURE sim;




-- VHDL Entity gates.mux2to1Signed.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:13 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY mux2to1Signed IS
    GENERIC( 
        dataBitNb : positive := 8;
        delay     : time     := gateDelay
    );
    PORT( 
        in0    : IN     signed (dataBitNb-1 DOWNTO 0);
        in1    : IN     signed (dataBitNb-1 DOWNTO 0);
        sel    : IN     std_uLogic;
        muxOut : OUT    signed (dataBitNb-1 DOWNTO 0)
    );

-- Declarations

END mux2to1Signed ;





ARCHITECTURE sim OF mux2to1Signed IS

  signal selInt: std_ulogic;

BEGIN

  selInt <= to_X01(sel);

  muxSelect: process(selInt, in0, in1)
  begin
    if selInt = '0' then
      muxOut <= in0 after delay;
    elsif selInt = '1' then
      muxOut <= in1 after delay;
    elsif in0 = in1 then
      muxOut <= in0 after delay;
    else
      muxOut <= (others => 'X') after delay;
    end if;
  end process muxSelect;

END ARCHITECTURE sim;




-- VHDL Entity gates.mux2to1.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:13 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY mux2to1 IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in0    : IN     std_uLogic;
        in1    : IN     std_uLogic;
        sel    : IN     std_uLogic;
        MuxOut : OUT    std_uLogic
    );

-- Declarations

END mux2to1 ;





ARCHITECTURE sim OF mux2to1 IS
  subtype tSelect is std_uLogic_vector(0 to 2);
BEGIN

  muxSelect: process(sel, in0, in1)
  begin
    if sel = '1' then
        muxOut <= in1 after delay;
    elsif sel = '0' then
        muxOut <= in0 after delay;
    else
    	muxOut <= 'X' after delay;
    end if;
  end process muxSelect;

-- muxSelect: process(sel, in0, in1)
--  begin
--   -- case tSelect'(to_X01(sel & in0 & in1)) is
--    case to_X01(tSelect'(sel & in0 & in1)) is
--      -- select in0
--      when "000" => muxOut <= '0' after delay;
--      when "001" => muxOut <= '0' after delay;
--      when "00X" => muxOut <= '0' after delay;
--      when "010" => muxOut <= '1' after delay;
--      when "011" => muxOut <= '1' after delay;
--      when "01X" => muxOut <= '1' after delay;
--      -- select in1
--      when "100" => muxOut <= '0' after delay;
--      when "110" => muxOut <= '0' after delay;
--      when "1X0" => muxOut <= '0' after delay;
--      when "101" => muxOut <= '1' after delay;
--      when "111" => muxOut <= '1' after delay;
--      when "1X1" => muxOut <= '1' after delay;
--      -- select in0 equal to in1
--      when "X00" => muxOut <= '0' after delay;
--      when "X11" => muxOut <= '1' after delay;
--      -- others
--      when others => muxOut <= 'X' after delay;
--    end case;
--  end process muxSelect;


END ARCHITECTURE sim;




-- VHDL Entity gates.and2inv1.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:34:52 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY and2inv1 IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        in2  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END and2inv1 ;





ARCHITECTURE sim OF and2inv1 IS
BEGIN
  out1 <= in1 and (not in2) after delay;
END ARCHITECTURE sim;




-- VHDL Entity gates.and2.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:34:52 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY and2 IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        in2  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END and2 ;





ARCHITECTURE sim OF and2 IS
BEGIN
  out1 <= in1 and in2 after delay;
END ARCHITECTURE sim;




-- VHDL Entity gates.demux1to2.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:34:47 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY demux1to2 IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        sel  : IN     std_ulogic;
        out0 : OUT    std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END demux1to2 ;





ARCHITECTURE sim OF demux1to2 IS
BEGIN

  process(sel, in1)
  begin
    -- default values
    out0 <= '0';
    out1 <= '0';

    -- selection
    case sel is
      when '0' => out0 <= in1 after delay;
      when '1' => out1 <= in1 after delay;
      when others => NULL;
    end case;

  end process;

END ARCHITECTURE sim;




-- VHDL Entity gates.logic1.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:13 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY logic1 IS
    PORT( 
        logic_1 : OUT    std_uLogic
    );

-- Declarations

END logic1 ;





ARCHITECTURE sim OF logic1 IS
BEGIN
  logic_1 <= '1';
END sim;




-- VHDL Entity gates.transUnsignedSigned.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:04 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY transUnsignedSigned IS
    GENERIC( 
        delay     : time     := gateDelay;
        dataBitNb : positive := 8
    );
    PORT( 
        in1  : IN     unsigned (dataBitNb-1 DOWNTO 0);
        out1 : OUT    signed (dataBitNb-1 DOWNTO 0)
    );

-- Declarations

END transUnsignedSigned ;





ARCHITECTURE sim OF transUnsignedSigned IS
BEGIN
  out1 <= signed(in1) after delay;
END ARCHITECTURE sim;




-- VHDL Entity operators.addSigned.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:37:25 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY addSigned IS
    GENERIC( 
        dataBitNb : positive := 8;
        delay     : time     := gateDelay
    );
    PORT( 
        in1  : IN     signed (dataBitNb-1 DOWNTO 0);
        in2  : IN     signed (dataBitNb-1 DOWNTO 0);
        out1 : OUT    signed (dataBitNb-1 DOWNTO 0)
    );

-- Declarations

END addSigned ;





ARCHITECTURE sim OF addSigned IS
BEGIN
  out1 <= in1 + in2 after delay;
END ARCHITECTURE sim;




--
-- VHDL Architecture Inverter.pwmModulator.PWM_3
--
-- Created:
--          by - elia.scapini.UNKNOWN (WEA20305)
--          at - 16:12:01 16.12.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
-- LIBRARY gates;
use work.gates.all;

-- LIBRARY operators;
-- LIBRARY sequential;

ARCHITECTURE PWM_3 OF pwmModulator IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL countUnsigned : unsigned(pwmBitNb-1 DOWNTO 0);
    SIGNAL count_1       : signed(pwmBitNb-1 DOWNTO 0);
    SIGNAL count_2       : signed(pwmBitNb-1 DOWNTO 0);
    SIGNAL count_3_or_1  : signed(pwmBitNb-1 DOWNTO 0);
    SIGNAL count_3level  : signed(pwmBitNb-1 DOWNTO 0);
    SIGNAL count_d1      : signed(pwmBitNb-1 DOWNTO 0);
    SIGNAL count_d2      : signed(pwmBitNb-1 DOWNTO 0);
    SIGNAL gt            : std_ulogic;
    SIGNAL gt1           : std_ulogic;
    SIGNAL in2           : signed(pwmBitNb-1 DOWNTO 0);
    SIGNAL in3           : signed(pwmBitNb-1 DOWNTO 0);
    SIGNAL logic_1       : std_uLogic;
    SIGNAL lt            : std_ulogic;
    SIGNAL out0          : std_uLogic;
    SIGNAL out1          : std_uLogic;
    SIGNAL out2          : std_uLogic;
    SIGNAL out3          : std_uLogic;


    -- Component Declarations
    COMPONENT and2
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        in2  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT and2inv1
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        in2  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT demux1to2
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        sel  : IN     std_ulogic ;
        out0 : OUT    std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT logic1
    PORT (
        logic_1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT mux2to1
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in0    : IN     std_uLogic ;
        in1    : IN     std_uLogic ;
        sel    : IN     std_uLogic ;
        MuxOut : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT mux2to1Signed
    GENERIC (
        dataBitNb : positive := 8;
        delay     : time     := gateDelay
    );
    PORT (
        in0    : IN     signed (dataBitNb-1 DOWNTO 0);
        in1    : IN     signed (dataBitNb-1 DOWNTO 0);
        sel    : IN     std_uLogic ;
        muxOut : OUT    signed (dataBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT transUnsignedSigned
    GENERIC (
        delay     : time     := gateDelay;
        dataBitNb : positive := 8
    );
    PORT (
        in1  : IN     unsigned (dataBitNb-1 DOWNTO 0);
        out1 : OUT    signed (dataBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT addSigned
    GENERIC (
        dataBitNb : positive := 8;
        delay     : time     := gateDelay
    );
    PORT (
        in1  : IN     signed (dataBitNb-1 DOWNTO 0);
        in2  : IN     signed (dataBitNb-1 DOWNTO 0);
        out1 : OUT    signed (dataBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT compareSigned
    GENERIC (
        dataBitNb : positive := 8;
        delay     : time     := gateDelay
    );
    PORT (
        a  : IN     signed (dataBitNb-1 DOWNTO 0);
        b  : IN     signed (dataBitNb-1 DOWNTO 0);
        eq : OUT    std_ulogic ;
        ge : OUT    std_ulogic ;
        gt : OUT    std_ulogic ;
        le : OUT    std_ulogic ;
        lt : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT counterEnable
    GENERIC (
        bitNb : positive := 8;
        delay : time     := gateDelay
    );
    PORT (
        clock    : IN     std_ulogic ;
        enable   : IN     std_ulogic ;
        reset    : IN     std_ulogic ;
        countOut : OUT    unsigned (bitNb-1 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : addSigned USE ENTITY operators.addSigned;
--     FOR ALL : and2 USE ENTITY gates.and2;
--     FOR ALL : and2inv1 USE ENTITY gates.and2inv1;
--     FOR ALL : compareSigned USE ENTITY operators.compareSigned;
--     FOR ALL : counterEnable USE ENTITY sequential.counterEnable;
--     FOR ALL : demux1to2 USE ENTITY gates.demux1to2;
--     FOR ALL : logic1 USE ENTITY gates.logic1;
--     FOR ALL : mux2to1 USE ENTITY gates.mux2to1;
--     FOR ALL : mux2to1Signed USE ENTITY gates.mux2to1Signed;
--     FOR ALL : transUnsignedSigned USE ENTITY gates.transUnsignedSigned;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    in2 <= (9 => '1', others=> '0');
    --in2(3) <= '1';

    -- HDL Embedded Text Block 2 eb2
    in3 <= (9 => '1', others=> '0');
    
    


    -- Instance port mappings.
    I14 : and2
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => gt1,
            in2  => amplitude(pwmBitNb-1),
            out1 => out2
        );
    I13 : and2inv1
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => lt,
            in2  => amplitude(pwmBitNb-1),
            out1 => out1
        );
    I2 : demux1to2
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => logic_1,
            sel  => gt,
            out0 => out0,
            out1 => out3
        );
    I3 : logic1
        PORT MAP (
            logic_1 => logic_1
        );
    I11 : mux2to1
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in0    => out0,
            in1    => out1,
            sel    => threeLevel,
            MuxOut => pwm1
        );
    I12 : mux2to1
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in0    => out3,
            in1    => out2,
            sel    => threeLevel,
            MuxOut => pwm2
        );
    I8 : mux2to1Signed
        GENERIC MAP (
            dataBitNb => pwmBitNb,
            delay     => gateDelay
        )
        PORT MAP (
            in0    => count_1,
            in1    => count_2,
            sel    => count_2(pwmBitNb-1),
            muxOut => count_d1
        );
    I9 : mux2to1Signed
        GENERIC MAP (
            dataBitNb => pwmBitNb,
            delay     => gateDelay
        )
        PORT MAP (
            in0    => count_1,
            in1    => count_3level,
            sel    => threeLevel,
            muxOut => count_3_or_1
        );
    I10 : mux2to1Signed
        GENERIC MAP (
            dataBitNb => pwmBitNb,
            delay     => gateDelay
        )
        PORT MAP (
            in0    => count_d2,
            in1    => count_d1,
            sel    => amplitude(pwmBitNb-1),
            muxOut => count_3level
        );
    I4 : transUnsignedSigned
        GENERIC MAP (
            delay     => gateDelay,
            dataBitNb => pwmBitNb
        )
        PORT MAP (
            in1  => countUnsigned,
            out1 => count_1
        );
    I5 : addSigned
        GENERIC MAP (
            dataBitNb => pwmBitNb,
            delay     => gateDelay
        )
        PORT MAP (
            in1  => count_d1,
            in2  => in3,
            out1 => count_d2
        );
    I7 : addSigned
        GENERIC MAP (
            dataBitNb => pwmBitNb,
            delay     => gateDelay
        )
        PORT MAP (
            in1  => count_1,
            in2  => in2,
            out1 => count_2
        );
    I0 : compareSigned
        GENERIC MAP (
            dataBitNb => pwmBitNb,
            delay     => gateDelay
        )
        PORT MAP (
            a  => amplitude,
            b  => count_3_or_1,
            eq => OPEN,
            ge => OPEN,
            gt => gt,
            le => OPEN,
            lt => OPEN
        );
    I6 : compareSigned
        GENERIC MAP (
            dataBitNb => pwmBitNb,
            delay     => gateDelay
        )
        PORT MAP (
            a  => amplitude,
            b  => count_3_or_1,
            eq => OPEN,
            ge => OPEN,
            gt => lt,
            le => OPEN,
            lt => gt1
        );
    I1 : counterEnable
        GENERIC MAP (
            bitNb => pwmBitNb,
            delay => gateDelay
        )
        PORT MAP (
            clock    => clock,
            enable   => en,
            reset    => reset,
            countOut => countUnsigned
        );

END PWM_3;




-- VHDL Entity Inverter.cordic.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:23:20 10/23/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY cordic IS
    GENERIC( 
        phaseBitNb  : positive := 16;
        signalBitNb : positive := 16;
        amplitude   : real     := 1.0
    );
    PORT( 
        clock  : IN     std_ulogic;
        phase  : IN     unsigned (phaseBitNb-1 DOWNTO 0);
        reset  : IN     std_ulogic;
        cosine : OUT    signed (signalBitNb-1 DOWNTO 0);
        sine   : OUT    signed (signalBitNb-1 DOWNTO 0)
    );

-- Declarations

END cordic ;





--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




library ieee;
  use ieee.math_real.all;
-- library Common;
  use work.CommonLib.all;

ARCHITECTURE RTL OF cordic IS

  constant iterationNb: positive := signalBitNb+2;

  subtype registerType is signed(signalBitNb-1+1 downto 0);
  type    registerArrayType is array (1 to iterationNb) of registerType;

  constant registerXInit: registerType := to_signed(
        integer(amplitude*0.6071*2.0**(signalBitNb-1)), registerType'length);
  constant registerYInit: registerType := to_signed(0, registerType'length);

  subtype phaseType is signed(phaseBitNb-1 downto 0);
  type phaseArrayType is array (1 to iterationNb) of phaseType;
  type directionArrayType is array(1 to iterationNb) of std_ulogic;
  type phaseSignArrayType is array(1 to iterationNb) of std_ulogic;


  function initPhaseArray return phaseArrayType is
    variable phaseIncrement: phaseArrayType;
  begin
    for index in 1 to phaseIncrement'length loop
      phaseIncrement(index) := to_signed(integer( arctan(1.0/2.0**(index-1)) / math_pi * 2.0**(phaseBitNb-1) ), phaseBitNb);
    end loop;
    return phaseIncrement;
  end initPhaseArray;

  constant phaseIncrement: phaseArrayType := initPhaseArray;
  signal phaseSign     : phaseSignArrayType;

  signal registerX     : registerArrayType;
  signal registerY     : registerArrayType;
  signal angle         : phaseArrayType;
  signal direction     : directionArrayType;

  signal cosine_int    : registerType;

BEGIN

  rotate: process(reset, clock)
  begin
    if reset = '1' then
      registerX <= (others => (others => '0'));
      registery <= (others => (others => '0'));
    elsif rising_edge(clock) then
      registerX(1) <= registerXInit;
      registerY(1) <= registerYInit;
      for index in 1 to iterationNb-1 loop
        if direction(index) = '0' then
          registerX(index+1) <= registerX(index) - shift_right(registerY(index), index-1);
          registerY(index+1) <= registerY(index) + shift_right(registerX(index), index-1);
        else
          registerX(index+1) <= registerX(index) + shift_right(registerY(index), index-1);
          registerY(index+1) <= registerY(index) - shift_right(registerX(index), index-1);
        end if;
      end loop;
    end if;
  end process rotate;

  trackAngle: process(reset, clock)
  begin
    if reset = '1' then
      angle <= (others => (others => '0'));
      phaseSign <= (others => '0');
    elsif rising_edge(clock) then
      if ( phase(phase'high) xor phase(phase'high-1) ) = '0' then
        angle(1) <= signed(phase);
      else
        angle(1)(angle(1)'high) <= phase(phase'high);
        angle(1)(angle(1)'high-1 downto 0) <= signed(not phase(phase'high-1 downto 0));
      end if;

      phaseSign(1) <= not(phase(phase'high) xor phase(phase'high-1));

      for index in 1 to iterationNb-1 loop
        phaseSign(index+1) <= phaseSign(index);
        if direction(index) = '0' then
          angle(index+1) <= angle(index) - phaseIncrement(index);
        else
          angle(index+1) <= angle(index) + phaseIncrement(index);
        end if;
      end loop;
    end if;
  end process trackAngle;

  dir: process(angle)
  begin
    for index in 1 to iterationNb loop
      direction(index) <= angle(index)(angle(index)'high);
    end loop;
  end process dir;

  sine <= to_signed((2**(sine'length-1)-1), sine'length) when (registerY(iterationNb) >= (2**(sine'length-1)))
     else to_signed(-(2**(sine'length-1)-1), sine'length) when (registerY(iterationNb) <= -(2**(sine'length-1)))
     else registerY(iterationNb)(sine'range);

  cosine_int <= registerX(iterationNb) when (phaseSign(iterationNb) = '1')
       else not registerX(iterationNb);

  cosine <= to_signed((2**(cosine'length-1)-1), cosine'length) when (cosine_int >= (2**(cosine'length-1)))
     else to_signed(-(2**(cosine'length-1)-1), cosine'length) when (cosine_int <= -(2**(cosine'length-1)))
     else cosine_int(cosine'range);

END ARCHITECTURE RTL;




--
-- VHDL Architecture Inverter.inverterControl.struct
--
-- Created:
--          by - elia.scapini.UNKNOWN (WEA20305)
--          at - 16:11:55 16.12.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

-- LIBRARY Inverter;

ARCHITECTURE struct OF inverterControl IS

    -- Architecture declarations
    constant nonOverlapBitNb: positive := requiredBitNb(integer(clockFrequency*nonOverlapPeriod*0.7));

    -- Internal signal declarations
    SIGNAL driveEn1   : std_ulogic;
    SIGNAL driveEn2   : std_ulogic;
    SIGNAL fullBridge : std_uLogic;
    SIGNAL phase      : unsigned(phaseBitNb-1 DOWNTO 0);
    SIGNAL pwm1       : std_uLogic;
    SIGNAL pwm2       : std_uLogic;
    SIGNAL sine       : signed(pwmBitNb-1 DOWNTO 0);
    SIGNAL step       : unsigned(phaseBitNb-1 DOWNTO 0);


    -- Component Declarations
    COMPONENT bufferUlogic
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT inverter
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT cordic
    GENERIC (
        phaseBitNb  : positive := 16;
        signalBitNb : positive := 16;
        amplitude   : real     := 1.0
    );
    PORT (
        clock  : IN     std_ulogic ;
        phase  : IN     unsigned (phaseBitNb-1 DOWNTO 0);
        reset  : IN     std_ulogic ;
        cosine : OUT    signed (signalBitNb-1 DOWNTO 0);
        sine   : OUT    signed (signalBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT nonOverlap
    GENERIC (
        counterBitNb : positive := 8
    );
    PORT (
        clock    : IN     std_ulogic ;
        driveEn  : IN     std_ulogic ;
        pwmIn    : IN     std_ulogic ;
        reset    : IN     std_ulogic ;
        pwmOut   : OUT    std_ulogic ;
        pwmOut_n : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT phaseCounter
    GENERIC (
        phaseBitNb : positive := 16
    );
    PORT (
        clock : IN     std_ulogic ;
        en    : IN     std_uLogic ;
        reset : IN     std_ulogic ;
        step  : IN     unsigned (phaseBitNb-1 DOWNTO 0);
        phase : OUT    unsigned (phaseBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT pwmModulator
    GENERIC (
        pwmBitNb : positive := 10
    );
    PORT (
        amplitude       : IN     signed (pwmBitNb-1 DOWNTO 0);
        clock           : IN     std_ulogic ;
        doubleFrequency : IN     std_ulogic ;
        en              : IN     std_ulogic ;
        reset           : IN     std_ulogic ;
        switchEvenOdd   : IN     std_ulogic ;
        threeLevel      : IN     std_ulogic ;
        pwm1            : OUT    std_ulogic ;
        pwm2            : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : bufferUlogic USE ENTITY gates.bufferUlogic;
--     FOR ALL : cordic USE ENTITY Inverter.cordic;
--     FOR ALL : inverter USE ENTITY gates.inverter;
--     FOR ALL : nonOverlap USE ENTITY Inverter.nonOverlap;
--     FOR ALL : phaseCounter USE ENTITY Inverter.phaseCounter;
--     FOR ALL : pwmModulator USE ENTITY Inverter.pwmModulator;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    step <= to_unsigned(integer(mainsFrequency/clockFrequency*2.0**step'length), step'length);
    

    -- HDL Embedded Text Block 2 eb2
    driveEn1 <= '1';
    --driveEn2 <= '1' when fullBridge = '1'
    --  else '0';
    driveEn2 <= '1';


    -- Instance port mappings.
    I_b1 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => pwm1,
            out1 => testOut(1)
        );
    I_b2 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => pwm2,
            out1 => testOut(2)
        );
    I_b3 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => reset,
            out1 => testOut(3)
        );
    I_b4 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => reset,
            out1 => testOut(4)
        );
    I_b5 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => reset,
            out1 => testOut(5)
        );
    I_b6 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => reset,
            out1 => testOut(6)
        );
    I_b7 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => reset,
            out1 => testOut(7)
        );
    I_b8 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => reset,
            out1 => testOut(8)
        );
    I0 : inverter
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => phase(phase'high),
            out1 => trigger
        );
    I_sin : cordic
        GENERIC MAP (
            phaseBitNb  => phaseBitNb,
            signalBitNb => pwmBitNb,
            amplitude   => sineAmplitude
        )
        PORT MAP (
            clock  => clock,
            phase  => phase,
            reset  => reset,
            cosine => OPEN,
            sine   => sine
        );
    I_nOver1 : nonOverlap
        GENERIC MAP (
            counterBitNb => nonOverlapBitNb
        )
        PORT MAP (
            clock    => clock,
            driveEn  => driveEn1,
            pwmIn    => pwm1,
            reset    => reset,
            pwmOut   => pwm1High,
            pwmOut_n => pwm1Low_n
        );
    I_nOver2 : nonOverlap
        GENERIC MAP (
            counterBitNb => nonOverlapBitNb
        )
        PORT MAP (
            clock    => clock,
            driveEn  => driveEn2,
            pwmIn    => pwm2,
            reset    => reset,
            pwmOut   => pwm2High,
            pwmOut_n => pwm2Low_n
        );
    I_phase : phaseCounter
        GENERIC MAP (
            phaseBitNb => phaseBitNb
        )
        PORT MAP (
            clock => clock,
            en    => sampleEn,
            reset => reset,
            step  => step,
            phase => phase
        );
    I_PWM : pwmModulator
        GENERIC MAP (
            pwmBitNb => pwmBitNb
        )
        PORT MAP (
            amplitude       => sine,
            clock           => clock,
            doubleFrequency => doubleFrequency,
            en              => pwmCountEn,
            reset           => reset,
            switchEvenOdd   => switchEvenOdd,
            threeLevel      => threeLevel,
            pwm1            => pwm1,
            pwm2            => pwm2
        );

END struct;




-- VHDL Entity Common.toggler.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:43:38 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

ENTITY toggler IS
    GENERIC( 
        counterBitNb : natural    := 18;
        invertInput  : std_ulogic := '0'
    );
    PORT( 
        clock  : IN     std_ulogic;
        input  : IN     std_ulogic;
        reset  : IN     std_ulogic;
        toggle : OUT    std_ulogic
    );

-- Declarations

END toggler ;





-- VHDL Entity Common.debouncer.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:43:38 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

ENTITY debouncer IS
    GENERIC( 
        counterBitNb : positive   := 18;
        invertInput  : std_ulogic := '0'
    );
    PORT( 
        clock     : IN     std_ulogic;
        input     : IN     std_ulogic;
        reset     : IN     std_ulogic;
        debounced : OUT    std_ulogic
    );

-- Declarations

END debouncer ;





-- filename:          debouncer.vhd
-- kind:              vhdl file
-- first created:     05.03.2012
-- created by:        zas
--------------------------------------------------------------------------------
-- History:
-- v0.1 : zas 05.03.2012 -- Initial Version
-- v0.2 : cof 22.01.2013 -- synchronization to clock
--                       -- direct reaction on both edges
--------------------------------------------------------------------------------
-- Description: 
-- Debounces a button on both edges.
--             _   _   ____________________   _   _
-- input  ____/ \_/ \_/                    \_/ \_/ \______
--              _____________________________
-- output _____/                             \____________
--
--------------------------------------------------------------------------------

ARCHITECTURE rtl OF debouncer IS
 
  signal debounceCounter : unsigned(counterBitNb-1 downto 0);
  signal inputSynch, inputDelayed, inputChanged : std_ulogic;
 
BEGIN
  ------------------------------------------------------------------------------
                                                   -- Synchronize input to clock
  synchInput: process(reset, clock)
  begin
    if reset = '1' then
      inputSynch <= '0';
    elsif rising_edge(clock) then
      inputSynch <= input xor invertInput;
    end if;
  end process synchInput;

  ------------------------------------------------------------------------------
                                                           -- Find edge on input
  delayInput: process(reset, clock)
  begin
    if reset = '1' then
      inputDelayed <= '0';
    elsif rising_edge(clock) then
      inputDelayed <= inputSynch;
    end if;
  end process delayInput;

  inputChanged <= '1' when inputDelayed /= inputSynch
    else '0';

  ------------------------------------------------------------------------------
                                                             -- Debounce counter
  countDeadTime: process(reset, clock)
  begin
    if reset = '1' then
      debounceCounter <= (others => '0');
    elsif rising_edge(clock) then
      if debounceCounter = 0 then
        if inputChanged = '1' then
          debounceCounter <= debounceCounter - 1;
        end if;
      else
        debounceCounter <= debounceCounter - 1;
      end if;
    end if;
  end process countDeadTime;

  ------------------------------------------------------------------------------
                                                                -- Update output
  updateOutput: process(reset, clock)
  begin
    if reset = '1' then
      debounced <= '0';
    elsif rising_edge(clock) then
      if (inputChanged = '1') and (debounceCounter = 0) then
        debounced <= input;
      elsif debounceCounter = 1 then
        debounced <= input;
      end if;
    end if;
  end process updateOutput;
 
END ARCHITECTURE rtl;




-- filename:          toggler.vhd
-- kind:              vhdl file
-- first created:     05.03.2012
-- created by:        zas
--------------------------------------------------------------------------------
-- History:
-- v0.1 : cof 22.01.2013 -- Initial version
--------------------------------------------------------------------------------
-- Description: 
-- Debounces a button on both edges.
--             _                            _
-- input  ____/ \__________________________/ \____________
--              _____________________________
-- output _____/                             \____________
--
-- If the generic "counterBitNb" is greater than zero, a debouncer is placed on
-- the input signal.
--
--------------------------------------------------------------------------------

ARCHITECTURE rtl OF toggler IS
 
  signal inputDebounced : std_ulogic;
  signal inputDelayed, inputChangedTo1 : std_ulogic;
  signal toggle_int : std_ulogic;

  COMPONENT debouncer
  GENERIC (
    counterBitNb : positive := 18;
    invertInput : std_ulogic := '0'
  );
  PORT (
    reset     : IN     std_ulogic ;
    clock     : IN     std_ulogic ;
    input     : IN     std_ulogic ;
    debounced : OUT    std_ulogic 
  );
  END COMPONENT;

BEGIN
  ------------------------------------------------------------------------------
                                                               -- Debounce input
  useInputDirectly: if counterBitNb = 0 generate
    inputDebounced <= input;
  end generate useInputDirectly;

  debounceInput: if counterBitNb > 0 generate
    I_debouncer : debouncer
      GENERIC MAP (
        counterBitNb => counterBitNb,
        invertInput => invertInput
      )
      PORT MAP (
        reset     => reset,
        clock     => clock,
        input     => input,
        debounced => inputDebounced
      );
  end generate debounceInput;

  ------------------------------------------------------------------------------
                                                           -- Find edge on input
  delayInput: process(reset, clock)
  begin
    if reset = '1' then
      inputDelayed <= '0';
    elsif rising_edge(clock) then
      inputDelayed <= inputDebounced;
    end if;
  end process delayInput;

  inputChangedTo1 <= '1' when (inputDebounced = '1') and (inputDelayed = '0')
    else '0';

  ------------------------------------------------------------------------------
                                                                -- Toggle output
  toggleOutput: process(reset, clock)
  begin
    if reset = '1' then
      toggle_int <= '0';
    elsif rising_edge(clock) then
      if inputChangedTo1 = '1' then
        toggle_int <= not toggle_int;
      end if;
    end if;
  end process toggleOutput;
 
   toggle <= toggle_int;
 
END ARCHITECTURE rtl;




-- VHDL Entity sequential.DFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:46:19 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY DFF IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        CLK : IN     std_uLogic;
        CLR : IN     std_uLogic;
        D   : IN     std_uLogic;
        Q   : OUT    std_uLogic
    );

-- Declarations

END DFF ;





ARCHITECTURE sim OF DFF IS
BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q <= '0' after delay;
    elsif rising_edge(clk) then
      q <= d after delay;
    end if;
  end process;

END sim;




--
-- VHDL Architecture Board.FPGA_inverterControl.struct
--
-- Created:
--          by - elia.scapini.UNKNOWN (WEA20305)
--          at - 09:39:11 10.12.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY common;
  use work.CommonLib.all;

-- LIBRARY Inverter;
-- LIBRARY sequential;

ARCHITECTURE struct OF FPGA_inverterControl IS

    -- Architecture declarations
    constant clockFrequency: real := 66.0E6;
    constant mainsFrequency: real := 50.0;
    constant pwmFrequency: real := 20.0E3;
    constant nonOverlapPeriod: real := 1.0E-6;
    
    constant phaseBitNb: positive := 27;
    constant sineAmplitude: real := 110.0 / 102.75 * 0.5;
    constant pwmBitNb: positive := 10;
    
    constant testLineNb: positive := 8;
    
    constant toggleCounterBitNb: positive := requiredBitNb(integer(1.0E-3*clockFrequency));

    -- Internal signal declarations
    SIGNAL button1         : std_uLogic;
    SIGNAL button2         : std_uLogic;
    SIGNAL button3         : std_uLogic;
    SIGNAL doubleFrequency : std_uLogic;
    SIGNAL pwmCountEn      : std_uLogic;
    SIGNAL reset           : std_ulogic;
    SIGNAL reset1          : std_ulogic;
    SIGNAL resetSynch      : std_ulogic;
    SIGNAL resetSynch_n    : std_ulogic;
    SIGNAL sampleEn        : std_uLogic;
    SIGNAL switchEvenOdd   : std_uLogic;
    SIGNAL testOut         : std_uLogic_vector(1 TO testLineNb);
    SIGNAL threeLevel      : std_uLogic;

    -- Implicit buffer signal declarations
    SIGNAL trigger_internal : std_uLogic;


    -- Component Declarations
    COMPONENT toggler
    GENERIC (
        counterBitNb : natural    := 18;
        invertInput  : std_ulogic := '0'
    );
    PORT (
        clock  : IN     std_ulogic ;
        input  : IN     std_ulogic ;
        reset  : IN     std_ulogic ;
        toggle : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT bufferUlogic
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT inverter
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT logic1
    PORT (
        logic_1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT inverterControl
    GENERIC (
        clockFrequency   : real     := 66.0E6;
        mainsFrequency   : real     := 50.0;
        pwmFrequency     : real     := 100.0E3;
        nonOverlapPeriod : real     := 1.0E-6;
        phaseBitNb       : positive := 32;
        sineAmplitude    : real     := 1.0;
        pwmBitNb         : positive := 10;
        testLineNb       : positive := 8
    );
    PORT (
        clock           : IN     std_ulogic ;
        doubleFrequency : IN     std_uLogic ;
        pwmCountEn      : IN     std_uLogic ;
        reset           : IN     std_ulogic ;
        sampleEn        : IN     std_uLogic ;
        switchEvenOdd   : IN     std_uLogic ;
        threeLevel      : IN     std_uLogic ;
        pwm1High        : OUT    std_uLogic ;
        pwm1Low_n       : OUT    std_uLogic ;
        pwm2High        : OUT    std_uLogic ;
        pwm2Low_n       : OUT    std_uLogic ;
        testOut         : OUT    std_uLogic_vector (1 TO testLineNb);
        trigger         : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT DFF
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        D   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : DFF USE ENTITY sequential.DFF;
--     FOR ALL : bufferUlogic USE ENTITY gates.bufferUlogic;
--     FOR ALL : inverter USE ENTITY gates.inverter;
--     FOR ALL : inverterControl USE ENTITY Inverter.inverterControl;
--     FOR ALL : logic1 USE ENTITY gates.logic1;
--     FOR ALL : toggler USE ENTITY Common.toggler;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    I2 : toggler
        GENERIC MAP (
            counterBitNb => toggleCounterBitNb,
            invertInput  => '0'
        )
        PORT MAP (
            clock  => clock,
            input  => button1,
            reset  => resetSynch,
            toggle => threeLevel
        );
    I5 : toggler
        GENERIC MAP (
            counterBitNb => toggleCounterBitNb,
            invertInput  => '0'
        )
        PORT MAP (
            clock  => clock,
            input  => button2,
            reset  => resetSynch,
            toggle => switchEvenOdd
        );
    I8 : toggler
        GENERIC MAP (
            counterBitNb => toggleCounterBitNb,
            invertInput  => '0'
        )
        PORT MAP (
            clock  => clock,
            input  => button3,
            reset  => resetSynch,
            toggle => doubleFrequency
        );
    I26 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => testOut(2),
            out1 => LED2
        );
    I27 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => testOut(1),
            out1 => LED1
        );
    I29 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => testOut(2),
            out1 => lp_PWM2
        );
    I33 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => testOut(1),
            out1 => lp_PWM1
        );
    I34 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => trigger_internal,
            out1 => lp_trigger
        );
    I1 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => reset_n,
            out1 => reset
        );
    I7 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => resetSynch_n,
            out1 => resetSynch
        );
    I18 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => testOut(8),
            out1 => LEDs_n(8)
        );
    I19 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => testOut(7),
            out1 => LEDs_n(7)
        );
    I20 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => testOut(6),
            out1 => LEDs_n(6)
        );
    I21 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => sampleEn,
            out1 => LEDs_n(5)
        );
    I22 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => threeLevel,
            out1 => LEDs_n(1)
        );
    I23 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => switchEvenOdd,
            out1 => LEDs_n(2)
        );
    I24 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => doubleFrequency,
            out1 => LEDs_n(3)
        );
    I25 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => pwmCountEn,
            out1 => LEDs_n(4)
        );
    I30 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => buttons_n(2),
            out1 => button3
        );
    I31 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => buttons_n(3),
            out1 => button2
        );
    I32 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => buttons_n(4),
            out1 => button1
        );
    I28 : logic1
        PORT MAP (
            logic_1 => reset1
        );
    I35 : logic1
        PORT MAP (
            logic_1 => pwmCountEn
        );
    I36 : logic1
        PORT MAP (
            logic_1 => sampleEn
        );
    I0 : inverterControl
        GENERIC MAP (
            clockFrequency   => clockFrequency,
            mainsFrequency   => mainsFrequency,
            pwmFrequency     => pwmFrequency,
            nonOverlapPeriod => nonOverlapPeriod,
            phaseBitNb       => phaseBitNb,
            sineAmplitude    => sineAmplitude,
            pwmBitNb         => pwmBitNb,
            testLineNb       => testLineNb
        )
        PORT MAP (
            clock           => clock,
            doubleFrequency => doubleFrequency,
            pwmCountEn      => pwmCountEn,
            reset           => resetSynch,
            sampleEn        => sampleEn,
            switchEvenOdd   => switchEvenOdd,
            threeLevel      => threeLevel,
            pwm1High        => pwm1High,
            pwm1Low_n       => pwm1Low_n,
            pwm2High        => pwm2High,
            pwm2Low_n       => pwm2Low_n,
            testOut         => testOut,
            trigger         => trigger_internal
        );
    I6 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => reset,
            D   => reset1,
            Q   => resetSynch_n
        );

    -- Implicit buffered output assignments
    trigger <= trigger_internal;

END struct;




